<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>并发编程之AQS那些事 | 余建波 Tech</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/css/highlight.css">

  
  <meta name="description" content="AbstractQueuedSynchronizer（AQS）是 Java 并发编程中绕不过去的一道坎，JUC 并发包下的 Lock、Semaphore、ReentrantLock 等都是基于 AQS 实现的。AQS 是一个抽象的同步框架，提供了原子性管理同步状态，基于阻塞队列模型实现阻塞和唤醒等待线程的功能 文章从 ReentrantLock 加锁、解锁应用 API 入手，逐步讲解 AQS 对应">
<meta property="og:type" content="article">
<meta property="og:title" content="并发编程之AQS那些事">
<meta property="og:url" content="https://yujianbo.tech/2022/08/02/%E4%BB%80%E4%B9%88%E6%98%AFAQS/index.html">
<meta property="og:site_name" content="余建波 Tech">
<meta property="og:description" content="AbstractQueuedSynchronizer（AQS）是 Java 并发编程中绕不过去的一道坎，JUC 并发包下的 Lock、Semaphore、ReentrantLock 等都是基于 AQS 实现的。AQS 是一个抽象的同步框架，提供了原子性管理同步状态，基于阻塞队列模型实现阻塞和唤醒等待线程的功能 文章从 ReentrantLock 加锁、解锁应用 API 入手，逐步讲解 AQS 对应">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201115144318438.png">
<meta property="og:image" content="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114220450839.png">
<meta property="og:image" content="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201115014812244.png">
<meta property="og:image" content="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201107234158422.png">
<meta property="og:image" content="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114161720040.png">
<meta property="og:image" content="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201106104059148.png">
<meta property="og:image" content="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201117222132211.png">
<meta property="og:image" content="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114213221013.png">
<meta property="og:image" content="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114213609335.png">
<meta property="og:image" content="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201109140133492.png">
<meta property="og:image" content="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201112180208027.png">
<meta property="og:image" content="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114141417895.png">
<meta property="og:image" content="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114140258406.png">
<meta property="og:image" content="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114141329010.png">
<meta property="og:image" content="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114144243192.png">
<meta property="article:published_time" content="2022-08-02T15:19:07.000Z">
<meta property="article:modified_time" content="2023-02-26T12:02:20.000Z">
<meta property="article:author" content="余建波">
<meta property="article:tag" content="AQS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201115144318438.png"><meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="wrapper">
    <header id="header">
  <h1 id="title">
    <a href="/">余建波 Tech</a>
  </h1>
  <nav>
    
    
      
      <a class="nav-link" href="/">Home</a>
    
      
        <span class="nav-spacer">×</span>
      
      <a class="nav-link" href="/archives">Archives</a>
    
    
  </nav>
</header>

    <div id="content">
      <article id="post-什么是AQS" class="article article-type-post" itemprop="blogPost" itemscope>
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 class="article-title" itemprop="headline name">
      并发编程之AQS那些事
    </h2>
  


        <div class="article-meta">
          <time class="article-date" datetime="2022-08-02T15:19:07.000Z" itemprop="datePublished">August 2, 2022, 11:19 PM</time>

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      
        <p>AbstractQueuedSynchronizer（AQS）是 Java 并发编程中绕不过去的一道坎，JUC 并发包下的 Lock、Semaphore、ReentrantLock 等都是基于 AQS 实现的。AQS 是一个抽象的同步框架，提供了原子性管理同步状态，基于阻塞队列模型实现阻塞和唤醒等待线程的功能</p>
<p>文章从 ReentrantLock 加锁、解锁应用 API 入手，逐步讲解 AQS 对应源码以及相关隐含流程</p>
<span id="more"></span>

<p>列出本篇文章大纲以及相关知识点，方便大家更好的理解</p>
<p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201115144318438.png"></p>
<h2 id="什么是-ReentrantLock"><a href="#什么是-ReentrantLock" class="headerlink" title="什么是 ReentrantLock"></a>什么是 ReentrantLock</h2><p>ReentrantLock 翻译为 <strong>可重入锁</strong>，指的是一个线程能够对 <strong>临界区共享资源进行重复加锁</strong></p>
<p>确保线程安全最常见的做法是利用锁机制（Lock、sychronized）来对 <strong>共享数据做互斥同步</strong>，这样在同一个时刻，只有 <strong>一个线程可以执行某个方法或者某个代码块</strong>，那么操作必然是 <strong>原子性的，线程安全的</strong></p>
<p>这里就有个疑问，因为 JDK 中关键字 <strong>synchronized</strong> 也能同时支持原子性以及线程安全</p>
<p><strong>有了 synchronized 关键字后为什么还需要 ReentrantLock?</strong></p>
<p>为了大家更好的掌握 ReentrantLock 源码，这里列出两种锁之间的区别</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Synchronized</th>
<th align="center">ReentrantLock</th>
</tr>
</thead>
<tbody><tr>
<td align="center">锁实现机制</td>
<td align="center">对象头监视器模式</td>
<td align="center">依赖 AQS</td>
</tr>
<tr>
<td align="center">灵活性</td>
<td align="center">不灵活</td>
<td align="center">支持响应中断、超时、尝试获取锁</td>
</tr>
<tr>
<td align="center">释放锁形式</td>
<td align="center">自动释放锁</td>
<td align="center">显示调用 unlock()</td>
</tr>
<tr>
<td align="center">支持锁类型</td>
<td align="center">非公平锁</td>
<td align="center">公平锁 &amp; 非公平锁</td>
</tr>
<tr>
<td align="center">条件队列</td>
<td align="center">单条件队列</td>
<td align="center">多个条件队列</td>
</tr>
<tr>
<td align="center">是否支持可重入</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
</tbody></table>
<br/>

<p>通过以上六个维度比对，可以看出 ReentrantLock 是要比 synchronized <strong>灵活以及支持功能更丰富</strong></p>
<h2 id="什么是-AQS"><a href="#什么是-AQS" class="headerlink" title="什么是 AQS"></a>什么是 AQS</h2><p>AQS（ AbstractQueuedSynchronizer ）是一个用来构建锁和同步器的抽象框架，只需要继承 AQS 就可以很方便的实现我们自定义的多线程同步器、锁</p>
<p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114220450839.png"></p>
<p>如图所示，在 <strong>java.util.concurrent</strong> 包下相关锁、同步器（常用的有 ReentrantLock、 ReadWriteLock、CountDownLatch…）都是基于 AQS 来实现</p>
<p><strong>AQS 是典型的模板方法设计模式</strong>，父类（AQS）定义好骨架和内部操作细节，具体规则由子类去实现</p>
<h3 id="AQS-核心原理"><a href="#AQS-核心原理" class="headerlink" title="AQS 核心原理"></a>AQS 核心原理</h3><p>如果被请求的共享资源未被占用，将当前请求资源的线程设置为独占线程，并将共享资源设置为锁定状态</p>
<p>AQS 使用一个 Volatile 修饰的 int 类型的成员变量 State 来表示同步状态，修改同步状态成功即为获得锁</p>
<p>Volatile 保证了变量在多线程之间的可见性，修改 State 值时通过 CAS 机制来保证修改的原子性</p>
<p>如果共享资源被占用，需要一定的阻塞等待唤醒机制来保证锁的分配，AQS 中会将竞争共享资源失败的线程添加到一个变体的 CLH 队列中</p>
<p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201115014812244.png"></p>
<p>关于支撑 AQS 特性的重要方法及属性如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">  <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">  	<span class="comment">// CLH 变体队列头、尾节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">  	<span class="comment">// AQS 同步状态</span></span><br><span class="line">   	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line">  	<span class="comment">// CAS 方式更新 state</span></span><br><span class="line">  	<span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CLH-队列"><a href="#CLH-队列" class="headerlink" title="CLH 队列"></a>CLH 队列</h3><p>既然是 AQS 中使用的是 CLH 变体队列，我们先来了解下 CLH 队列是什么</p>
<p>CLH：Craig、Landin and Hagersten 队列，是 <strong>单向链表实现的队列</strong>。申请线程只在本地变量上自旋，<strong>它不断轮询前驱的状态</strong>，如果发现 <strong>前驱节点释放了锁就结束自旋</strong></p>
<p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201107234158422.png"></p>
<p>通过对 CLH 队列的说明，可以得出以下结论</p>
<ol>
<li>CLH 队列是一个单向链表，保持 FIFO 先进先出的队列特性</li>
<li>通过 tail 尾节点（原子引用）来构建队列，总是指向最后一个节点</li>
<li>未获得锁节点会进行自旋，而不是切换线程状态</li>
<li>并发高时性能较差，因为未获得锁节点不断轮训前驱节点的状态来查看是否获得锁</li>
</ol>
<p>AQS 中的队列是 CLH 变体的虚拟双向队列，通过将每条请求共享资源的线程封装成一个节点来实现锁的分配</p>
<p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114161720040.png"></p>
<p>相比于 CLH 队列而言，AQS 中的 CLH 变体等待队列拥有以下特性</p>
<ol>
<li>AQS 中队列是个双向链表，也是 FIFO 先进先出的特性</li>
<li>通过 Head、Tail 头尾两个节点来组成队列结构，通过 volatile 修饰保证可见性</li>
<li>Head 指向节点为已获得锁的节点，是一个虚拟节点，节点本身不持有具体线程</li>
<li>获取不到同步状态，会将节点进行自旋获取锁，自旋一定次数失败后会将线程阻塞，相对于 CLH 队列性能较好</li>
</ol>
<h3 id="认识-AOS"><a href="#认识-AOS" class="headerlink" title="认识 AOS"></a>认识 AOS</h3><p>抽象类 AQS 同样继承自抽象类 AOS（AbstractOwnableSynchronizer）</p>
<p>AOS 内部只有一个 Thread 类型的变量，提供了获取和设置当前独占锁线程的方法</p>
<p>主要作用是 <strong>记录当前占用独占锁（互斥锁）的线程实例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="comment">// 独占线程（不参与序列化）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line">    <span class="comment">// 设置当前独占的线程</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setExclusiveOwnerThread</span><span class="params">(Thread thread)</span> &#123;</span><br><span class="line">        exclusiveOwnerThread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回当前独占的线程</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Thread <span class="title function_">getExclusiveOwnerThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> exclusiveOwnerThread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么要掌握-AQS"><a href="#为什么要掌握-AQS" class="headerlink" title="为什么要掌握 AQS"></a>为什么要掌握 AQS</h3><p>如何能够体现程序员的水平，那就是掌握大多数人所不掌握的技术，这也是为什么面试时 AQS 高频出现的原因，因为它不简单</p>
<p>最初接触 ReentrantLock 以及 AQS 的时候，看到源码就是一头雾水，Debug 跟着跟着就 <strong>迷失了自己</strong>，相信这也是大多数人的反应</p>
<p>正是因为经历过，所以才能从小白的心理上出发，把其中的知识点能够尽数梳理</p>
<p>作者写的很用心，看过这篇文章的小伙伴，不敢保证百分百理解 AQS 和 ReentrantLock 的原理，但是一定会有所收获</p>
<h2 id="独占加锁源码解析"><a href="#独占加锁源码解析" class="headerlink" title="独占加锁源码解析"></a>独占加锁源码解析</h2><h3 id="什么是独占锁"><a href="#什么是独占锁" class="headerlink" title="什么是独占锁"></a>什么是独占锁</h3><p>独占锁也叫排它锁，是指该锁一次只能被一个线程所持有，如果别的线程想要获取锁，只有等到持有锁线程释放</p>
<p>获得排它锁的线程即能读数据又能修改数据，与之对立的就是共享锁</p>
<p>共享锁是指该锁可被多个线程所持有。如果线程 T 对数据 A 加上共享锁后，则其他线程只能对 A 再加共享锁，不能加排它锁</p>
<p>获得共享锁的线程只能读数据，不能修改数据</p>
<h3 id="独占锁加锁"><a href="#独占锁加锁" class="headerlink" title="独占锁加锁"></a>独占锁加锁</h3><p>ReentrantLock 就是独占锁的一种实现方式，接下来看代码中如何使用 ReentrantLock 完成独占式加锁业务逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建非公平锁</span></span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">// 获取锁操作</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行代码逻辑</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁操作</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>new ReentrantLock() 构造函数默认创建的是非公平锁 NonfairSync</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时也可以在创建锁构造函数中传入具体参数创建公平锁 FairSync</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line">--- ReentrantLock</span><br><span class="line"><span class="comment">// true 代表公平锁，false 代表非公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FairSync、NonfairSync 代表公平锁和非公平锁，两者都是 ReentrantLock 静态内部类，只不过实现不同锁语义</p>
<p><strong>公平锁 FairSync</strong></p>
<ol>
<li>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁</li>
<li>公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU 唤醒阻塞线程的开销比非公平锁大</li>
</ol>
<p><strong>非公平锁 NonfairSync</strong></p>
<ol>
<li>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁</li>
<li>非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU 不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁</li>
</ol>
<p>两者的都继承自 ReentrantLock 静态抽象内部类 Sync，<strong>Sync 类继承自 AQS</strong>，这里就有个疑问</p>
<p>这些锁都没有直接继承 AQS，而是定义了一个 <strong>Sync 类去继承 AQS</strong>，为什么要这样呢？</p>
<p>因为 <strong>锁面向的是使用用户</strong>，<strong>同步器面向的则是线程控制</strong>，那么在锁的实现中聚合同步器而不是直接继承 AQS 就可以很好的 <strong>隔离二者所关注的事情</strong></p>
<p>通过对不同锁种类的讲解以及 ReentrantLock 内部结构的解析，根据上下级关系继承图，加深其理解</p>
<p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201106104059148.png"></p>
<p>这里以非公平锁举例，查看加锁的具体过程，详细信息下文会详细说明</p>
<p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201117222132211.png"></p>
<p>看一下非公平锁加锁方法 lock 内部怎么做的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();</span><br><span class="line">--- ReentrantLock</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line">--- Sync</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Sync#lock</strong> 为抽象方法，最终会调用其子类非公平锁的方法 lock</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非公平加锁方法有两个逻辑</p>
<ol>
<li>通过比较并替换 State（同步状态）成功与否决定是否获得锁，设置 State 为 1 表示成功获取锁，并将当前线程设置为独占线程</li>
<li>修改 State 值失败则进入尝试获取锁流程，acquire 方法为 AQS 提供的方法</li>
</ol>
<p>compareAndSetState 以 CAS 比较并替换的方式将 State 值设置为 1，表示同步状态被占用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, StateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setExclusiveOwnerThread 设置当前线程为独占锁拥有线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setExclusiveOwnerThread</span><span class="params">(Thread thread)</span> &#123;</span><br><span class="line">    exclusiveOwnerThread = thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>acquire 对整个 AQS 做到了承上启下的作用，通过 tryAcquire 模版方法进行尝试获取锁，获取锁失败包装当前线程为 Node 节点加入等待队列排队</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tryAcquire 是 AQS 中抽象模版方法，但是内部会有默认实现，虽然默认的方法内部抛出异常，<strong>为什么不直接定义为抽象方法呢?</strong></p>
<p>因为 AQS 不只是对独占锁实现了抽象，同时还包括共享锁；不同锁定义了不同类别的方法，共享锁就不需要 tryAcquire，如果定义为抽象方法，继承 AQS 子类都需要实现该方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NonfairSync 类中有 tryAcquire 重写方法，继续查看具体如何进行非公平方式获取锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">  	<span class="comment">// State 等于0表示此时无锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">      	<span class="comment">// 再次使用CAS尝试获取锁, 表现为非公平锁特性</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">          	<span class="comment">// 设置线程为独占锁线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 如果当前线程等于已获取锁线程, 表现为可重入锁特性</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">      	<span class="comment">// 设置 State</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 如果state不等于0并且独占线程不是当前线程, 返回 false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 tryAcquire 做了取反，如果设置 state 失败并且独占锁线程不是自己本身返回 false，通过取反会进入接下来的流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Node-入队流程"><a href="#Node-入队流程" class="headerlink" title="Node 入队流程"></a>Node 入队流程</h3><p>尝试获得锁失败，接下来会将线程组装成为 Node 进行入队流程</p>
<p>Node 是 AQS 中最基本的数据结构，也是 CLH 变体队列中的节点，Node 有 <strong>SHARED（共享）、EXCLUSIVE（独占）</strong> 两种模式，文章主要介绍 EXCLUSIVE 模式，不相关的属性和方法不予介绍</p>
<p>下面列出关于 Node EXCLUSIVE 模式的一些关键方法以及状态信息</p>
<table>
<thead>
<tr>
<th align="center">关键方法与属性</th>
<th align="center">对应含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">waitStatus</td>
<td align="center">当前节点在队列中处于什么状态</td>
</tr>
<tr>
<td align="center">thread</td>
<td align="center">表示节点对应的线程</td>
</tr>
<tr>
<td align="center">prev</td>
<td align="center">前驱指针，指向本节点的上一个节点</td>
</tr>
<tr>
<td align="center">next</td>
<td align="center">后继指针，指向本节点的下一个节点</td>
</tr>
<tr>
<td align="center">predecessor</td>
<td align="center">返回前驱节点，没有的话抛出 NPE 异常</td>
</tr>
</tbody></table>
<p>Node 中独占锁相关的 waitStatus 属性分别有以下几种状态</p>
<table>
<thead>
<tr>
<th align="center">属性值</th>
<th align="center">值含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">Node 被初始化后的默认值</td>
</tr>
<tr>
<td align="center">CANCELLED</td>
<td align="center">值为 1，由于中断或超时，节点被取消</td>
</tr>
<tr>
<td align="center">SIGNAL</td>
<td align="center">值为-1，表示节点的后继节点即将被阻塞</td>
</tr>
<tr>
<td align="center">CONDITION</td>
<td align="center">值为-2，表示节点在等待队列中，节点线程等待唤醒</td>
</tr>
</tbody></table>
<p>介绍完 Node 相关基础知识，看一下请求锁线程如何被包装为 Node，又是如何初始化入队的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 获取等待队列的尾节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">  	<span class="comment">// 如果尾节点不为空, 将 node 设置为尾节点, 并将原尾节点 next 指向 新的尾节点node</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 尾部为空，enq 执行</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pred 为队列的尾节点，根据尾节点是否为空会执行对应流程</p>
<ol>
<li>尾节点不为空，证明队列已被初始化，那么需要将对应的 node（当前线程）设置为新的尾节点，也就是入队操作；将 node 节点的前驱指针指向 pred（尾节点），并将 node 通过 CAS 方式设置为 AQS 等待队列的尾节点，替换成功后将原来的尾节点后继指针指向新的尾节点</li>
<li>尾节点为空，证明还没有初始化队列，执行 enq 方法进行初始化队列</li>
</ol>
<p>enq 方法执行初始化队列操作，等待队列中虚拟化的头节点也是在这里产生</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">          	<span class="comment">// 虚拟化一个空Node, 并将head指向空Node</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">              	<span class="comment">// 将尾节点等于头节点</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	<span class="comment">// node上一条指向尾节点</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">          	<span class="comment">// 设置node为尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">              	<span class="comment">// 设置原尾节点的下一条指向node</span></span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行 enq 方法的前提就是队列尾节点为空，为什么还要再判断尾节点是否为空？</strong></p>
<p>因为 enq 方法中是一个死循环，循环过程中 t 的值是不固定的。假如执行 enq 方法时队列为空，for 循环会执行两遍不同的处理逻辑</p>
<ol>
<li>尾节点为空，虚拟化出一个新的 Node 头节点，这时队列中只有一个元素，为了保证 AQS 队列结构的完整性，会将尾节点指向头节点，第一遍循环结束</li>
<li>第二遍不满足尾节点为空条件，执行 else 语句块，node 节点前驱指针指向尾节点，并将 node 通过 CAS 设置为新的尾节点，成功后设置原尾节点的后继指针指向 node，至此入队成功。返回的 t 无意义，只是为了终止死循环</li>
</ol>
<p>画两张图来理解 enq 方法整体初始化 AQS 队列流程，假设 T1、T2 两个线程争取锁，T1 成功获得锁，T2 进行入队操作</p>
<ol>
<li>T2 进行入队操作，循环第一遍，尾节点为空。开始初始化头节点，并将尾节点指向头节点，最终队列形式是这样纸滴</li>
</ol>
<p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114213221013.png"></p>
<ol start="2">
<li>循环第二遍，需要将 node 设置为新的尾节点。逻辑如下：尾节点不为空，设置 node 前驱指针指向尾节点，并将 node 设置为尾节点，原尾节点 next 指针指向 node</li>
</ol>
<p>addWaiter 方法就是为了让 Node 入队，并且维护出一个双向队列模型</p>
<p>入队执行成功后，会在 acquireQueued 再次尝试竞争锁，竞争失败后会将线程阻塞</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>acquireQueued 方法会尝试自旋获取锁，获取失败对当前线程实施阻塞流程，这也是为了避免无意义的自旋，对比 CLH 队列性能优化的体现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">          	<span class="comment">// 获取node上一个节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">          	<span class="comment">// 如果node为头节点 &amp; 尝试获取锁成功</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">              	<span class="comment">// 此时当前node线程获取到了锁</span></span><br><span class="line">              	<span class="comment">// 将node设置为新的头节点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">              	<span class="comment">// help GC</span></span><br><span class="line">                p.next = <span class="literal">null</span>;</span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 node.predecessor() 获取节点的前驱节点，前驱节点为空抛出空指针异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取到前驱节点后进行两步逻辑判断</p>
<ol>
<li>判断前驱节点 p 是否为头节点，为 true 进行尝试获取锁，获取锁成功设置当前节点为新的头节点，并将原头节点的后驱指针设为空</li>
<li>前驱节点不是头节点或者尝试加锁失败，执行线程休眠阻塞操作</li>
</ol>
<p>如果 node 获得锁后，setHead 将节点设置为队列头，从而实现出队效果，出于 GC 的考虑，清空未使用的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHead</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="literal">null</span>;</span><br><span class="line">    node.prev = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shouldParkAfterFailedAcquire 需要重点关注下，流程相对比较难理解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ws 表示为当前申请锁节点前驱节点的等待状态，代码中包含三个逻辑，分别是：</p>
<ol>
<li>ws &#x3D;&#x3D; Node.SIGNAL，表示需要将申请锁节点进行阻塞</li>
<li>ws &gt; 0，表示等待队列中包含被取消节点，需要调整队列</li>
<li>如果 ws &#x3D;&#x3D; Node.SIGNAL || ws &gt;0 都为 false，使用 CAS 的方式将前驱节点等待状态设置为 Node.SIGNAL</li>
</ol>
<blockquote>
<p>设置当前节点的前置节点等待状态为 Node.SIGNAL，表示当前节点获取锁失败，需要进行阻塞操作</p>
</blockquote>
<p>还是通过几张图来理解流程，假设此时 T1、T2 线程来争夺锁</p>
<p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114213609335.png"></p>
<p>T1 线程获得锁，T2 进入 AQS 等待队列排队，并通过 CAS 将 T2 节点的前驱节点等待状态置为 SIGNAL</p>
<p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201109140133492.png"></p>
<p>执行切换前驱节点等待状态后返回 false，继续进行循环尝试获取同步状态</p>
<blockquote>
<p>这一步操作保证了线程能进行多次重试，尽量避免线程状态切换</p>
</blockquote>
<p>如果 T1 线程没有释放锁，T2 线程第二次执行到 shouldParkAfterFailedAcquire 方法，因为前驱节点已设置为 SIGNAL，所以会直接返回 true，执行线程阻塞操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">  	<span class="comment">// 将当前线程进行阻塞</span></span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">  	<span class="comment">// 方法返回了当前线程的中断状态，并将当前线程的中断标识设置为false</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LockSupport.park 方法将当前等待队列中线程进行阻塞操作，线程执行一个从 RUNNABLE 到 WAITING 状态转变</p>
<p>如果线程被唤醒，通过执行 Thread.interrupted 查看中断状态，这里的中断状态会被传递到 acquire 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">      	<span class="comment">// 如果线程被中断, 这里会再次设置中断状态</span></span><br><span class="line">      	<span class="comment">// 因为如果线程中断, 调用 Thread.interrupted 虽然会返回 true, 但是会清除线程中断状态</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使线程从 park 方法中唤醒后发现自己被中断了，但是不影响接下来的获取锁操作，如果需要设置线程中断来影响流程，可以使用 lockInterruptibly 获得锁，抛出检查异常 InterruptedException</p>
<h3 id="cancelAcquire"><a href="#cancelAcquire" class="headerlink" title="cancelAcquire"></a>cancelAcquire</h3><p>取消排队方法是 AQS 中比较难的知识点，不容易被理解</p>
<p>当线程因为自旋或者异常等情况获取锁失败，会调用此方法进行取消正在获取锁的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cancelAcquire</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 不存在的节点直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    node.thread = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * waitStatus &gt; 0 代表节点为取消状态</span></span><br><span class="line"><span class="comment">     * while循环会将node节点的前驱指针指向一个非取消状态的节点</span></span><br><span class="line"><span class="comment">     * pred等于当前节点的前驱节点（非取消状态）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取过滤后的前驱节点的后继节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">predNext</span> <span class="operator">=</span> pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置node等待状态为取消状态</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 🚩步骤一，如果node是尾节点，使用CAS将pred设置为新的尾节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">      	<span class="comment">// 设置pred（新tail）的后驱指针为空</span></span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> ws;</span><br><span class="line">      	<span class="comment">// 🚩步骤二，node的前驱节点pred（非取消状态）!= 头节点</span></span><br><span class="line">        <span class="keyword">if</span> (pred != head</span><br><span class="line">            	<span class="comment">/**</span></span><br><span class="line"><span class="comment">            	 * 1. pred等待状态等于SIGNAL</span></span><br><span class="line"><span class="comment">            	 * 2. ws &lt;= 0并且设置pred等待状态为SIGNAL</span></span><br><span class="line"><span class="comment">            	 */</span></span><br><span class="line">            	&amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL)))</span><br><span class="line">            	<span class="comment">// pred中线程不为空</span></span><br><span class="line">            	&amp;&amp; pred.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line">          	<span class="comment">/**</span></span><br><span class="line"><span class="comment">          	 * 1. 当前节点的后继节点不为空</span></span><br><span class="line"><span class="comment">          	 * 2. 后继节点等待状态&lt;=0（表示非取消状态）</span></span><br><span class="line"><span class="comment">          	 */</span></span><br><span class="line">            <span class="keyword">if</span> (next != <span class="literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">              	<span class="comment">// 设置pred的后继节点设置为当前节点的后继节点</span></span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	<span class="comment">// 🚩步骤三，如果当前节点为头节点或者上述条件不满足, 执行唤醒当前节点的后继节点流程</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑稍微复杂一些，比较重要是以下三个逻辑</p>
<ol>
<li><p>步骤一当前节点为尾节点的话，设置 pred 节点为新的尾节点，成功设置后再将 pred 后继节点设置为空（尾节点不会有后继节点）</p>
</li>
<li><p>步骤二需要满足以下四个条件才会将前驱节点（非取消状态）的后继指针指向当前节点的后继指针</p>
<p>1）当前节点不等于尾节点</p>
<p>2）当前节点前驱节点不等于头节点</p>
<p>3）前驱节点的等待状态不为取消状态</p>
<p>4）前驱节点的拥有线程不为空</p>
</li>
<li><p>如果不满足步骤二的话，会执行步骤三相关逻辑，唤醒后继节点</p>
</li>
</ol>
<p><strong>步骤一：</strong></p>
<p>假设当前取消节点为尾节点并且前置节点无取消节点，现有等待队列如下图，执行下述逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">    compareAndSetNext(pred, predNext, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201112180208027.png"></p>
<p>将 pred 设置为新的尾节点，并将 pred 后继节点设置为空，因为尾节点不会有后继节点了</p>
<p>T4 线程所在节点因无引用指向，会被 GC 垃圾回收处理</p>
<p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114141417895.png"></p>
<p><strong>步骤二：</strong></p>
<p>如果当前需要取消节点的前驱节点为取消状态节点，如图所示</p>
<p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114140258406.png"></p>
<p>设置 pred（非取消状态）的后继节点为 node 的后继节点，并设置 node 的 next 为 自己本身</p>
<p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114141329010.png"></p>
<p><strong>线程 T2、T3 所在节点因为被 T4 所直接或间接指向，如何进行 GC?</strong></p>
<p>AQS 等待队列中取消状态节点会在 shouldParkAfterFailedAcquire 方法中被 GC 垃圾回收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">    &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">    pred.next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>T4 线程所在节点获取锁失败尝试停止时，会执行上述代码，执行后的等待队列如下图所示</p>
<p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114144243192.png"></p>
<p>等待队列中取消状态节点就可以被 GC 垃圾回收了，至此加锁流程也就结束了，下面继续看如何解锁</p>
<h2 id="独占解锁源码解析"><a href="#独占解锁源码解析" class="headerlink" title="独占解锁源码解析"></a>独占解锁源码解析</h2><p>解锁流程相对于加锁简单了很多，调用对应 API-lock.unlock()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--- ReentrantLock</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">--- AQS</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">  	<span class="comment">// 尝试释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="释放锁同步状态"><a href="#释放锁同步状态" class="headerlink" title="释放锁同步状态"></a>释放锁同步状态</h3><p>tryRelease 是定义在 AQS 中的抽象方法，通过 Sync 类重写了其实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">  	<span class="comment">// 如果当前线程不等于拥有锁线程, 抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">      	<span class="comment">// 将拥有锁线程设置为空</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 设置State状态为0, 解锁成功</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="唤醒后继节点"><a href="#唤醒后继节点" class="headerlink" title="唤醒后继节点"></a>唤醒后继节点</h3><p>此时 State 值已被释放，对于头节点的判断这块流程比较有意思</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">		unparkSuccessor(h);</span><br></pre></td></tr></table></figure>

<p><strong>什么情况下头节点为空</strong>，当线程还在争夺锁，队列还未初始化，头节点必然是为空的</p>
<p>当头节点等待状态等于 0，证明后继节点还在自旋，不需要进行后继节点唤醒</p>
<p>如果同时满足上述两个条件，会对等待队列头节点的后继节点进行唤醒操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">  	<span class="comment">// 获取node等待状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">  	<span class="comment">// 获取node的后继节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">  	<span class="comment">// 如果下个节点为空或者被取消, 遍历队列查询非取消节点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">      	<span class="comment">// 从队尾开始查找, 等待状态 &lt;= 0 的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 满足 s != null &amp;&amp; s.waitStatus &lt;= 0</span></span><br><span class="line">  	<span class="comment">// 执行 unpark</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么查找队列中未被取消的节点需要从尾部开始？</strong></p>
<p>这个问题有两个原因可以解释，分别是 Node 入队和清理取消状态的节点</p>
<ol>
<li><p>先从 addWaiter 入队时说起，compareAndSetTail(pred, node)、pred.next &#x3D; node 并非原子操作，如果在执行 pred.next &#x3D; node 前进行 unparkSuccessor，就没有办法通过 next 指针向后遍历，所以才会从后向前找寻非取消的节点</p>
</li>
<li><p>cancelAcquire 方法也有导致使用 head 无法遍历全部 Node 的因素，因为先断开的是 next 指针，prev 指针并未断开</p>
</li>
</ol>
<h3 id="唤醒阻塞后流程"><a href="#唤醒阻塞后流程" class="headerlink" title="唤醒阻塞后流程"></a>唤醒阻塞后流程</h3><p>当线程获取锁失败被 park 后进入了阻塞模式，前驱节点释放锁后会进行唤醒 unpark，被阻塞线程状态回归 RUNNABLE 状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">  	<span class="comment">// 从此位置唤醒</span></span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被唤醒线程检查自身是否被中断，返回自身中断状态到 acquireQueued</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设自身被中断，设置 interrupted &#x3D; true，继续通过循环尝试获取锁，获取锁成功后返回 interrupted 中断状态</p>
<p><strong>中断状态本身并不会对加锁流程产生影响</strong>，被唤醒后还是会不断进行获取锁，直到获取锁成功进行返回，返回中断状态是为了后续补充中断纪录</p>
<p>如果线程被唤醒后发现中断，成功获取锁后会将中断状态返回，补充中断状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>selfInterrupt 就是对线程中断状态的一个补充，补充状态成功后，流程结束</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selfInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="阅读源码小技巧"><a href="#阅读源码小技巧" class="headerlink" title="阅读源码小技巧"></a>阅读源码小技巧</h2><p><strong>1、从全局掌握要阅读的源码提供了什么功能</strong></p>
<p>这也是我一直推崇的学习源码方式，学习源码的关键点是抓住主线流程，在了解主线之前不要最开始就研究到源码实现细节中，否则很容易迷失在细枝末节的代码中</p>
<p>以文章中的 AQS 举例，当你知道了它是一个抽象队列同步器，使用它可以更简单的构造锁和同步器等实现</p>
<p>然后从中理解 tryAcquire、tryRelease 等方法实现，这样是不是可以更好的理解与 AQS 与其子类相关的代码</p>
<p><strong>2、把不易理解的源码粘贴出来，整理好格式打好备注</strong></p>
<p>一般源码中的行为格式和我们日常敲代码是不一样的，而且 JDK 源码中的变量命名实在是惨不忍睹</p>
<p>所以就应该将难以理解的源码粘贴出，标上对应注释以及调整成易理解的格式，这样对于源码的阅读就会轻松很多</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>平常工作中接触到 AQS 相关知识还是很多的，知其然知其所以然，文章以 ReentrantLock 作为切入点，讲述了其公平锁和非公平锁的概念，以及对应 AQS 中 CLH、AOS 等不容易被发现的概念</p>
<p>针对 ReentrantLock 以及 AQS 加锁、解锁、排队等流程进行了详细说明，以图文并茂的方式讲述了其流程源码实现细节，这里希望在看的小伙伴都能收获 AQS 相关知识</p>
<p>参考资料</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/11/15/java-lock.html">https://tech.meituan.com/2018/11/15/java-lock.html</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/y_e3ciU-hiqlb5vseuOFyw">https://mp.weixin.qq.com/s/y_e3ciU-hiqlb5vseuOFyw</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/197840259?utm_source=wechat_session">https://zhuanlan.zhihu.com/p/197840259?utm_source=wechat_session</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/java_lyvee/article/details/98966684">https://blog.csdn.net/java_lyvee/article/details/98966684</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/197840259?utm_source=wechat_session">https://zhuanlan.zhihu.com/p/197840259?utm_source=wechat_session</a></li>
</ul>

      
    </div>
    
    
    <div class="article-category">
      
        <b>Categories:</b>
        <a class="article-category-link" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a>
      
      
        <br/>
      
      
        <b>Tags:</b>
        <a class="article-tag-none-link" href="/tags/AQS/" rel="tag">AQS</a>
      
    </div>
    
    
  </div>
</article>

  
<nav id="article-nav" class="article-nav">
  
    <a href="/2022/12/02/%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          并发编程之阻塞队列
        
      </div>
    </a>
  
  
    <a href="/2022/08/02/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E4%B8%8D%E8%A2%AB%E9%94%80%E6%AF%81/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          线程池核心线程如何不被销毁
        
      </div>
    </a>
  
</nav>






    </div>
  </div>
  




<div id="settings-container">
  <div id="dark-mode">dark</div>
  <div id="sans-font">sans</div>
</div>
<script type="text/javascript">
let d=document,r=d.documentElement.style,f=r.setProperty.bind(r),l=localStorage,s=l.getItem('s')||(window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches),n=l.getItem('n'),m=d.getElementById("dark-mode"),b=()=>{f('--bg-color','#fafafa');f('--code-bg-color','#f4f4f4');f('--text-color','#212121');f('--secondary-color','#808080');f('--tertiary-color','#b0b0b0');f('--link-color','#b5c8cf');f('--link-hover-color','#618794');f('--link-bg-color','#dae4e7');f('--selection-color','#dae4e7');m.innerHTML="dark"},c=()=>{f('--bg-color','#212121');f('--code-bg-color','#292929');f('--text-color','#fff');f('--secondary-color','#c0c0c0');f('--tertiary-color','#6e6e6e');f('--link-color','#4d6b75');f('--link-hover-color','#96b1bb');f('--link-bg-color','#5d828e');f('--selection-color','#acc1c9');m.innerHTML="light"},o=d.getElementById("sans-font"),e=()=>{f('--body-stack','"Lora", "Georgia", "Times New Roman", serif');o.innerHTML="sans"},g=()=>{f('--body-stack','"Lato", "Lucida Grande", "Lucida Sans Unicode", "Lucida Sans", "Verdana", sans-serif');o.innerHTML="serif"};m.onclick=()=>{if(s==2){s=1;l.setItem('s',s);c()}else{s=2;l.setItem('s',s);b()}};o.onclick=()=>{if(n==2){n=1;l.setItem('n',n);g()}else{n=2;l.setItem('n',n);e()}};if(!s){s=2;l.setItem('s',2)};if(s==1){c()};if(!n){n=2;l.setItem('n',2)};if(n==1){g()};
</script>




</body>
</html>
